# 3. 명령어

## 3-1. 소스 코드와 명령어

### 고급 언어와 저급 언어

- 고급 언어 : 사람을 위한 언어(Java 등)
- 저급 언어 : 컴퓨터가 직접 이해하고 실행할 수 있는 언어

컴퓨터는 저급 언어만 이해하고 실행할 수 있기 때문에, 고급 언어로 작성한 소스 코드는 저급 언어로 변환되어야 한다.

저급 언어에는 기계어, 어셈블리어 두 종류가 있다.

- 기계어
  - 0과 1의 명령어 비트로 이루어진 언어
- 어셈블리어
  - 기계어는 사람이 이해하기 어려워 등장
  - 기계어를 읽기 편한 형태로 번역한 언어

<br/>

### 컴파일 언어와 인터프리터 언어

고급 언어가 저급 언어로 변환되는 방식에는 컴파일 / 인터프리트 방식의 두 가지가 있다.

- 컴파일 방식으로 작동하는 프로그래밍 언어 = 컴파일 언어
- 인터프리트 방식으로 작동하는 프로그래밍 언어 = 인터프리터 언어

#### 컴파일 언어

- C가 대표적
- 컴파일러 : 컴파일을 수행해 주는 도구
- 소스 코드 전체를 훑어보며 오류를 살펴보고 처음부터 끝까지 저급 언어로 컴파일
- 오류 발견하면 컴파일 실패
- 컴파일러를 통해 저급 언어로 변환된 코드 = 목적 코드(object code)

#### 인터프리터 언어

- Python이 대표적
- 인터프리터 : 인터프리트를 수행해 주는 도구
- 소스 코드를 한 줄씩 차례로 실행한다.
- 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없다.
- N번째 줄에 오류가 있어도 N-1번째 줄까지는 올바르게 수행된다.
- 컴파일 언어보다 느리다.

<br/>

### 목적 파일 vs 실행 파일

- 목적 코드로 이루어진 파일 = 목적 파일
- 실행 코드로 이루어진 파일 = 실행 파일(.exe)

목적 코드가 실행 파일이 되기 위해서는 링킹을 거쳐야 한다.

링킹 = 각 파일의 기능을 연결 짓는 작업

링킹 작업까지 거치면 하나의 실행 파일이 만들어진다.

<br/>

## 3-2) 명령어의 구조

### 연산 코드와 오퍼랜드

명령어는 연산 코드와 오퍼랜드로 구성된다.

- 연산 코드 : 명령어가 수행할 연산
- 오퍼랜드(operand) : 연산에 사용할 데이터 or 연산에 사용할 데이터가 저장된 위치

연산 코드는 연산자, 오퍼랜드는 피연산자라고도 부른다.

> - 연산 코드 필드 = 연산 코드가 담기는 영역
> - 오퍼랜드 필드 = 오퍼랜드가 담기는 영역

#### 오퍼랜드

오퍼랜드 필드에는 많은 경우 연산에 사용할 데이터가 저장될 위치, 즉 메모리 주소나 레지스터 이름이 담긴다.

따라서 오퍼랜드 필드를 주소 필드라고 부르기도 한다.

오퍼랜드는 명령어 안에 여러 개가 있을 수 있다.

- 오퍼랜드가 하나도 없는 명령어 : 0-주소 명령어
- 오퍼랜드가 하나인 명령어 : 1-주소 명령어
- 오퍼랜드가 두 개인 명령어 : 2-주소 명령어
- 3개인 명령어 : 3-주소 명령어

#### 연산 코드

크게 네 가지의 유형으로 나눌 수 있다.

- 데이터 전송
- 산술/논리 연산
- 제어 흐름 변경
- 입출력 제어

명령어의 종류와 생김새는 CPU마다 다르므로 연산 코드의 종류와 생김새도 CPU마다 다르다.

대부분의 CPU가 공통으로 이해하는 대표적인 연산 코드의 종류

- 데이터 전송
  - `MOVE` : 데이터를 옮겨라
  - `STORE` : 메모리에 저장하라
  - `LOAD(FETCH)` : 메모리에서 CPU로 데이터를 가져와라
  - `PUSH` : 스택에 데이터를 저장하라
  - `POP` : 스택의 최상단 데이터를 가져와라
- 산술/논리 연산
  - `ADD/SUBSTRACT/MULTIPLY/DIVIDE` : 덧셈/뺄셈/곱셈/나눗셈을 수행하라
  - `INCREMENT/DECREMENT` : 오퍼랜드에 1을 더하라/빼라
  - `AND/OR/NOT`: AND/OR/NOT 연산을 수행하라
  - `COMPARE` : 두 개의 숫자 또는 TRUE/FALSE 값을 비교하라
- 제어 흐름 변경
  - `JUMP` : 특정 주소로 실행 순서를 옮겨라
  - `CONDITIONAL JUMP` : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
  - `HALT` : 프로그램의 실행을 멈춰라
  - `CALL` : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
  - `RETURN` : CALL을 호출할 때 저장했던 주소로 돌아가라
- 입출력 제어
  - `READ(INPUT)` : 특정 입출력 장치로부터 데이터를 읽어라
  - `WRITE(OUTPUT)` : 특정 입출력 장치로 데이터를 써라
  - `START IO` : 입출력 장치를 시작하라
  - `TEST IO` : 입출력 장치의 상태를 확인하라

<br/>

### 주소 지정 방식

오퍼랜드 필드에 주소를 담는 이유

- 하나의 명령어가 n비트이고 연산 코드 필드가 m비트일 때
- 1-주소 명령어일 때의 오퍼랜드 필드의 길이는 n-m비트
- 2-주소 명령어, 3-주소 명령어라면 크기가 더욱 작아진다.

오퍼랜드 필드 안에 메모리 주소를 넣으면 <br/>
-> 표현할 수 있는 데이터 크기 = 하나의 메모리, 레지스터에 저장할 수 있는 공간

연산의 대상이 되는 데이터가 저장된 위치를 **유효 주소**라고 한다.

주소 지정 방식 ? <br/>
오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법

#### 대표적인 주소 지정 방식

- 즉시 주소 지정 방식

  - 데이터를 오퍼랜드 필드에 직접 명시하는 방식
  - 데이터의 크기가 작아진다는 단점
  - 데이터를 찾는 과정이 없어 빠르다는 장점

- 직접 주소 지정 방식

  - 오퍼랜드 필드에 유효 주소를 직접 명시하는 방식
  - 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 크다.
  - 여전히 오퍼랜드 필드의 길이가 연산 코드 길이만큼 짧아져 제한이 있다.

- 간접 주소 지정 방식

  - 유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식
  - 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 넓다
  - 두 번 접근이 필요해서 느리다.

- 레지스터 주소 지정 방식

  - 직접 주소 지정 방식과 비슷
  - 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
  - 메모리보다 레지스터 접근이 더 빠름 -> 직접 주소 지정 방식보다 빠르다.
  - 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.

- 레지스터 간접 주소 지정 방식
  - 연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식
  - 메모리에 접근하는 횟수가 한 번이라 간접 주소 지정 방식보다 빠르다.
